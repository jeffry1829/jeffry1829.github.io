<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>6797  // PETJELINUX</title>
    <style>html{text-rendering:optimizeLegibility;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing: grayscale}*+*{box-sizing:border-box;margin:0}@media(min-width:35em){.col{display:table-cell}.\31{width:5%}.\33{width:22%}.\34{width:30%}.\35{width:40%}.\32{width:15%}.row{display:table;border-spacing:1em 0}}.row,.w-100{width:100%}.card:focus,hr{outline:0;border:solid var(--primary-color)}.card,pre{padding:1em;border:solid var(--light)}.c{max-width:60em;padding:1em;margin:auto;font:1em/1.6 var(--font)}p{padding:.5em 0}h6{font:300 1em var(--font)}h5{font:300 1.2em var(--font)}h3{font:300 2em var(--font)}h4{font:300 1.5em var(--font)}h2{font:300 2.2em var(--font)}h1{font:300 2.5em var(--font)}a{text-decoration:none}a,a:hover{border-bottom:1px dotted rgba(0,0,0,.5)}a:hover{background:var(--link-highlight-color)}pre{overflow:auto}td,th{padding:1em;text-align:left;border-bottom:solid var(--light)}footer{padding:0 0 3vmin;font-family:var(--font);position:static}ol, ol li { margin-left: 0; padding-left: 0; list-style: none }        :root{            --font:"Helvetica Neue", Helvetica, Arial, sans-serif;            --link-highlight-color:#ff0;        }        .ta { animation: 1.2s ease-out a; animation-fill-mode: both}        @keyframes a {            0% { opacity: 0; }            100% { opacity: 1; }        }        .l {border-left:1px solid #000;padding-left:2em}        @media(max-width:35em){            .l { border-left: none; padding-left: initial}        }</style>
    
    <link href="https://fonts.googleapis.com/css?family=Anton" rel="stylesheet">
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-121925525-1');
    </script>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocas-ui/2.3.3/tocas.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tocas-ui/2.3.3/tocas.js" async></script>

    <link rel="stylesheet" href="prism.css">
    <script src="prism.js" async></script>
    <!--
        PLUGINS
        https://prismjs.com/plugins/line-highlight/
        https://prismjs.com/plugins/line-numbers/
        https://prismjs.com/plugins/show-language/
        https://prismjs.com/plugins/keep-markup/
        https://prismjs.com/plugins/normalize-whitespace/
        https://prismjs.com/plugins/unescaped-markup/
    -->
</head>
<body>
    <header style="
        display: inline-table; width: 100%;
        font-family: Anton, Impact, 'Arial Black', 'Arial Rounded MT Bold', sans-serif;
        font-size: 45vw; letter-spacing: 3px; text-align: center;
        transform: translate3d(0, -.1em, 0); color: #1c1c1b;
        line-height: 1em;
    ">6797</header>
    <div class="ts text container top attached header">Contact</div>
    <div class="ts text attached container segment">
        Email: jeffry1829@gmail.com(在沒討論版之前，如果想交流就傳封信來吧！)<br/>
    </div>
    <div class="ts text container top attached header">2018/8/1 //LCA</div>
    <div class="ts text attached container segment">
        為了寫TIOJ1163學了一下倍增法LCA，蠻輕巧的，沒有原本想像得複雜<br/>
        <a href="https://zhyack.github.io/posts/2015_12_22_LCA-Binary-Lifting-Note.html" target="_blank">外部連結</a><br/>
        基本上就三個函式:<br/>
        ->dfs儲存每個點的深度+儲存上一個點(father[][0]))<br/>
        ->loop儲存每個點所有存在的2的冪次的祖先節點<br/>
        ->assume depth(u)>depth(v)，先將u移到v的深度(這裡的depth並沒有考慮權重，不會發生沒有深度相同的點的問題)，
        接著再用相似的方法把已經同處同樣深度的u,v慢慢上移，即可找到LCA。<br/>
        備註:網站裡的程式碼並非完全正確，有些地方仍需加上father不為-1的判斷。<br/>
        圖像化直覺link:<br/>
        <a href="https://blog.csdn.net/HowardEmily/article/details/72887538" target="_blank">外部連結</a><br/>
    </div>
    <div class="ts text container top attached header">
        2018/8/1 //關於LCA求MST(Minimal Spanning Tree)(最小生成樹)兩點唯一路徑權重最大值
    </div>
    <div class="ts text attached container segment">
        和上一篇一樣，我還是在想TIOJ1163，我看過解答，我始終想不透為何麼LCA可以快速解這問題，<br/>
        結果只是我想多了，其實想法異常粗暴。(EDIT:其實也要用倍增法，詳見下篇文章)<br/><br/>
        這題目大部分會被寫在求次小生成樹的解法上，因為次小生成樹的解法是:<br/>
        先求MST(kruskal算法)，並一一嘗試每一個剩下沒連接到的邊(u,v,w(weight))，
        必定形成環，檢查(u,v)間另外一條路徑上的最大權重，刪掉這edge，
        接上我們正在嘗試的edge(u,v,w)，會得到新的樹權重和，最後輸出權重最小的結果就好。<br/><br/>
        回到正題，這個問題的解法是:<br/>
        ->let LCA=lca(u,v)<br/>
        ->define walk(u,v):<br/>
        ->->assume depth(u)>depth(v) and v is an ancestor of u<br/>
        ->->因為在MST,(u,v)間只有一條路徑，所以我們可以一步一步往u上面的祖先走，並記錄最長的邊(可以用倍增法
        ，詳見下篇文章)<br/>
        ->->得到(u,v)間的最大權重<br/>
        ->end walk<br/>
        ->(因為walk傳入的(u,v)必須是祖先-子孫關係，所以我們必須先求LCA)<br/>
        ->現在我們就可以得到答案是max(walk(u,LCA),walk(v,LCA))<br/>
        ->end<br/>
        備註:我在寫這題時全部測資都SegFault，目前還沒找到原因...(EDIT:解決，詳見下篇文章)<br/><br/>
        放一些文章:<br/>
        TIOJ1163解答<br/>
        <a href="https://blog.ototot.tk/2017/04/tioj-1163-6.html" target="_blank">外部連結</a><br/>
        上面那個文章裡面的連結，關於walk的詳細說明(其實沒有說明，在code裡)<br/>
        <a href="https://blog.ototot.tk/2017/03/tioj-1445.html" target="_blank">外部連結</a><br/>
        另一種用到LCA的解法，只是我不知道怎麼生成那棵樹<br/>
        <a href="http://blog.sina.com.cn/s/blog_51cea4040100ss3n.html" target="_blank">外部連結</a><br/>
        另一種解法，好像是從生成MST時動手，沒看太懂<br/>
        <a href="https://blog.csdn.net/zengchen__acmer/article/details/17323429" target="_blank">外部連結</a><br/>
        次小生成樹<br/>
        <a href="https://oi.men.ci/minimum-spanning-tree-notes/" target="_blank">外部連結</a>
    </div>
    <div class="ts text container top attached header">2018/8/3 //對前兩篇文章的總結</div>
    <div class="ts text attached container segment">
        我終於AC了，雖然排名不是頂端，但我認為可能已經不那麼重要了，畢竟我完全照著網路解答(tototo大佬的那個解答)
        的思路寫，僅僅有一個if條件(lca函式那，不知道為何不用交換u,v如果v比u深)我實在不知道做了什麼神奇的動作可以
        省去和我多紀錄了每個點的depth(深度)來進行一些判斷，
        基本上沒什麼區別，在最後還是差了40ms左右，我就把這個當做是解題系統的誤差吧(。而至於為什麼之前一直SegFault，
        居然是因為我的dfs函式不小心回傳型別寫成int，而我最後並沒有回傳東西，g++ -Wall -Wextra居然什麼都沒有講，
        我花了將近一天半重複debug，最後開Ubuntu虛擬機裝clang編譯，才終於告訴我我忘記回傳了，沒回傳不知道為什麼
        在這情況會產生UB(Undefined Behavior) :(<br/><br/>
        回到正題，現在來說一些從tototo大佬解答整理出來的特殊的優化方法。<br/>
        1.dfs時紀錄每個點的進入/離開時間，撰寫函式anc(ancestor)用以判斷(u,v)兩點的祖先-子孫關係，在最後求lca時
        可以從兩個迴圈變成一個迴圈，大概長這樣:<br/>
        <img class="ts link fluid image" src="優化後的lca.PNG"><br/>
        2.可以省去所有判斷father是否為-1的father初始化方法:不要有"到不了"狀態，也就是不要有-1。<br/>
        具體方法為在初始化時對每一個點的所有祖先都設為自己，如此一來最後原本會是"到不了"的狀態(-1))，會變成端點的號碼。<br/>
        這樣敘述"非常"不清楚，可以自己想像一下。<br/>
        3.倍增法walk優化:這個優化並沒有非常特殊，一般來說都已經倍增法求LCA了，自然會想到用倍增法優化walk函式。<br/>
        具體作法是把father[i][j]的型別從int改成pair<int,int>，第一個欄位是原本的值，第二個欄位就是從i點到i的2^j
        祖先點路徑上權重最大值，參考一下答案應該不難實作。<br/><br/>
        一些連結:<br/>
        高仿oToToT大佬的解答<br/>
        <a href="https://gist.github.com/jeffry1829/afbe03aafb85f3fb356b166469588cc8" target="_blank">外部連結</a><br/>
        無優化解答(然而和優化後解答只差30ms)<br/>
        <a href="https://gist.github.com/jeffry1829/f52c54c99960b5b477ca7e7aba223fa9" target="_blank">外部連結</a>
    </div>
    <div class="ts text container top attached header">2018/8/3 //沒學過asm的人隨手記一記</div>
    <div class="ts text attached container segment">
        上一篇文章提到了因為忘記return所以爆炸。我做了一些小實驗想看看為什麼，雖然最後還是不知道哪裡會發生UB，仍姑且
        記一記。<br/><br/>
        <img class="ts link fluid image" src="dfs_asm1.jpg"><br/>
        圖一(-O2)<br/>
        <img class="ts link fluid image" src="dfs_asm2.jpg"><br/>
        圖二<br/>
        <img class="ts link fluid image" src="dfs_asm3.jpg"><br/>
        圖三<br/>
        <img class="ts link fluid image" src="dfs_asm4.jpg"><br/>
        圖四<br/><br/>
        圖二可以看到sub $0x8 %rsp(64bit的return address size)，圖三可以看到push r13,r12,rbp,rbx，圖四可以看到pop回來
        並且retq(因為是64bit)，雖然因為我不會/也懶得一個一個instructor慢慢查，我只能說乍看之下應該是不會有太大的問題的(
        也就是認為不會產生UB)，也就是仍然無法解釋UB的來龍去脈。(return應該是%eax，已經xor %eax %eax了 應該回傳值會被認為
        是0?)
    </div>
<!--    <div class="ts text container top attached header">TEST</div>
    <div class="ts text attached container segment">
        <pre class="line-numbers" data-line="5">
            <code class="language-clike">
#include &lt;bits/stdc++.h&gt;
#define _V 30010
#define _E 50010
#define maxB 15  //2^15&gt;30000
using namespace std;
struct WE {
  int v, d;
};
struct EDGE {
  int x, y, d;
};
EDGE E1[_E];
vector&lt;WE&gt; G2[_V];
int djs[_V], dsc[_V], depth[_V], father[_V][maxB], fatherwei[_V], V, E, Q;
bool visited[_V];
inline void dsunion(int s1, int s2) {
  if (dsc[s1] &lt; dsc[s2]) swap(s1, s2);
  djs[s2] = djs[s1];
  dsc[s1] += dsc[s2];
}
inline int dsfind(int x) {
  if (djs[x] != x) djs[x] = dsfind(djs[x]);
  return djs[x];
}
void dfs(int v, int d, int fa, int weight) {
  visited[v] = true;
  depth[v] = d;
  father[v][0] = fa;
  fatherwei[v] = weight;
  for (int i = 0; i &lt; G2[v].size(); i++) {
    if (!visited[G2[v][i].v]) {
      dfs(G2[v][i].v, d + 1, v, G2[v][i].d);
    }
  }
}
inline void findfather() {
  for (int j = 1; j &lt; maxB; j++)
    for (int i = 0; i &lt; V; i++)
      if (~father[i][j - 1])
        father[i][j] = father[father[i][j - 1]][j - 1];
}
inline int lca(int u, int v) {  // be used when everything is ready
  if (depth[u] &lt; depth[v]) swap(u, v);
  for (int i = maxB - 1; i &gt;= 0; i--)
    if (~father[u][i] &amp;&amp; depth[father[u][i]] &gt;= depth[v])
      u = father[u][i];
  if (u == v) return v;
  for (int i = maxB - 1; i &gt;= 0; i--)
    if (~father[u][i] &amp;&amp; ~father[v][i] &amp;&amp; father[u][i] != father[v][i]) {
      u = father[u][i];
      v = father[v][i];
    }
  return father[u][0];
}
inline void getE1() {
  int X, Y, d;
  for (int i = 0; i &lt; E; i++) {
    cin &gt;&gt; X &gt;&gt; Y &gt;&gt; d;
    X--;
    Y--;  // because input vertices are 1~V
    E1[i] = (EDGE){X, Y, d};
  }
}
inline void kruskal() {
  sort(E1, E1 + E, [](EDGE l, EDGE r) -&gt; bool { return l.d &lt; r.d; });
  for (int i = 0; i &lt; E; i++) {
    EDGE e = E1[i];
    int s1, s2;
    if ((s1 = dsfind(e.x)) != (s2 = dsfind(e.y))) {
      dsunion(s1, s2);
      G2[e.x].push_back((WE){e.y, e.d});
      G2[e.y].push_back((WE){e.x, e.d});
    }
  }
}
inline void genG2() {
  kruskal();
}
inline int walk(int u, int v) {  //return max
  int maxedge = -1;
  if (depth[u] &lt; depth[v]) swap(u, v);
  while (u != v) {
    maxedge = max(maxedge, fatherwei[u]);
    u = father[u][0];
  }
  return maxedge;
}
main(void) {
  cin.tie(0);
  ios_base::sync_with_stdio(0);
  cin &gt;&gt; V &gt;&gt; E;
  memset(dsc, 1, sizeof(int) * _V);
  memset(depth, 0, sizeof(int) * _V);
  memset(fatherwei, 0, sizeof(int) * _V);
  for (int i = 0; i &lt; V; i++)
    for (int j = 0; j &lt; maxB; j++)
      father[i][j] = -1;
  memset(visited, 0, sizeof(bool) * _V);
  memset(E1, 0, sizeof(EDGE) * _E);
  for (int i = 0; i &lt; V; i++)
    djs[i] = i;
  getE1();
  genG2();
  for (int i = 0; i &lt; V; i++) {
    if (!visited[i]) {
      dfs(i, 0, -1, -1);
    }
  }
  findfather();
  cin &gt;&gt; Q;
  for (int i = 0; i &lt; Q; i++) {
    int ST, ED;
    cin &gt;&gt; ST &gt;&gt; ED;
    ST--;
    ED--;
    if (dsfind(ST) != dsfind(ED)) {
      cout &lt;&lt; &quot;-1\n&quot;;
      continue;
    }
    if (ST == ED) {
      cout &lt;&lt; &quot;0\n&quot;;
      continue;
    }
    int LCA = lca(ST, ED);
    cout &lt;&lt; max(walk(ST, LCA), walk(ED, LCA)) &lt;&lt; '\n';
  }
  return 0;
}
            </code>
        </pre>
    </div>-->
    <div class="ts text container top attached header">2018/8/7 //TIOJ1220</div>
    <div class="ts text attached container segment">
        暫時不作詳細說明，因為僅僅是拿到AC，但複雜度太高<br/>
        原始碼:<br/>
        <a href="https://gist.github.com/jeffry1829/bf9b74a77b87e1ecd65dec426bf6e0d3" target="_blank">外部連結</a>
    </div>
    <div class="ts text container top attached header">2018/8/1 //JustDoIt</div>
    <div class="ts text attached container segment">
        Do it<br/>
        Just Do it<br/>
        Don't let your dreams be dreams.<br/>
        Yesterday,you said tomorrow.<br/>
        So just do it!!<br/>
        Make your dreams come true!<br/>
        Just do it!!!<br/>
        Some people dream success.<br/>
        While you are gonna wake up and work hard at it!<br/>
        Nothing is impossible!<br/>
        (snorts)<br/>
        You should get to the point where anyone else would quit.<br/>
        And you are not going to (stop) there!<br/>
        NO!What are you waiting for?<br/>
        Do it!<br/>
        Just<br/>
        Do it!<br/>
        Yes we can!<br/>
        Just<br/>
        Do it!<br/>
        If you are tired of starting over,<br/>
        stop giving up<br/>
        and work hard at it<br/>
        <img class="ts link fluid image" src="justdoit.png">
    </div>
</body>
</html>