<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>6797  // PETJELINUX</title>
    <style>html{text-rendering:optimizeLegibility;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing: grayscale}*+*{box-sizing:border-box;margin:0}@media(min-width:35em){.col{display:table-cell}.\31{width:5%}.\33{width:22%}.\34{width:30%}.\35{width:40%}.\32{width:15%}.row{display:table;border-spacing:1em 0}}.row,.w-100{width:100%}.card:focus,hr{outline:0;border:solid var(--primary-color)}.card,pre{padding:1em;border:solid var(--light)}.c{max-width:60em;padding:1em;margin:auto;font:1em/1.6 var(--font)}p{padding:.5em 0}h6{font:300 1em var(--font)}h5{font:300 1.2em var(--font)}h3{font:300 2em var(--font)}h4{font:300 1.5em var(--font)}h2{font:300 2.2em var(--font)}h1{font:300 2.5em var(--font)}a{text-decoration:none}a,a:hover{border-bottom:1px dotted rgba(0,0,0,.5)}a:hover{background:var(--link-highlight-color)}pre{overflow:auto}td,th{padding:1em;text-align:left;border-bottom:solid var(--light)}footer{padding:0 0 3vmin;font-family:var(--font);position:static}ol, ol li { margin-left: 0; padding-left: 0; list-style: none }        :root{            --font:"Helvetica Neue", Helvetica, Arial, sans-serif;            --link-highlight-color:#ff0;        }        .ta { animation: 1.2s ease-out a; animation-fill-mode: both}        @keyframes a {            0% { opacity: 0; }            100% { opacity: 1; }        }        .l {border-left:1px solid #000;padding-left:2em}        @media(max-width:35em){            .l { border-left: none; padding-left: initial}        }</style>
    
    <link href="https://fonts.googleapis.com/css?family=Anton" rel="stylesheet">
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-121925525-1');
    </script>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocas-ui/2.3.3/tocas.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tocas-ui/2.3.3/tocas.js" async></script>
    <!--
        <link rel="stylesheet" href="prism.css">
        <script src="prism.js" async></script>
        PLUGINS
        https://prismjs.com/plugins/line-highlight/
        https://prismjs.com/plugins/line-numbers/
        https://prismjs.com/plugins/show-language/
        https://prismjs.com/plugins/keep-markup/
        https://prismjs.com/plugins/normalize-whitespace/
        https://prismjs.com/plugins/unescaped-markup/
    -->
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
    
    <script src='live2d/lib/live2d.min.js'></script>
    
    <script src='live2d/framework/Live2DFramework.js'></script>

    <script src="live2d/src/utils/MatrixStack.js"></script>
    <script src="live2d/src/utils/ModelSettingJson.js"></script>
    <script src="live2d/src/PlatformManager.js"></script>
    <script src="live2d/src/LAppDefine.js"></script>
    <script src="live2d/src/LAppModel.js"></script>
    <script src="live2d/src/LAppLive2DManager.js"></script>
    <script src="live2d/src/SampleApp1.js"></script>
</head>
<body>
    <header style="
        display: inline-table; width: 100%;
        font-family: Anton, Impact, 'Arial Black', 'Arial Rounded MT Bold', sans-serif;
        font-size: 45vw; letter-spacing: 3px; text-align: center;
        transform: translate3d(0, -.1em, 0); color: #1c1c1b;
        line-height: 1em;
    ">6797</header>
    <div class="ts text container top attached header">Contact</div>
    <div class="ts text attached container segment">
        Email: jeffry1829@gmail.com(在沒討論版之前，如果想交流就傳封信來吧！)<br/>
    </div>
    <div class="ts text container top attached header">2018/8/1 //LCA</div>
    <div class="ts text attached container segment">
        為了寫TIOJ1163學了一下倍增法LCA，蠻輕巧的，沒有原本想像得複雜<br/>
        <a href="https://zhyack.github.io/posts/2015_12_22_LCA-Binary-Lifting-Note.html" target="_blank">外部連結</a><br/>
        基本上就三個函式:<br/>
        ->dfs儲存每個點的深度+儲存上一個點(father[][0]))<br/>
        ->loop儲存每個點所有存在的2的冪次的祖先節點<br/>
        ->assume depth(u)>depth(v)，先將u移到v的深度(這裡的depth並沒有考慮權重，不會發生沒有深度相同的點的問題)，
        接著再用相似的方法把已經同處同樣深度的u,v慢慢上移，即可找到LCA。<br/>
        備註:網站裡的程式碼並非完全正確，有些地方仍需加上father不為-1的判斷。<br/>
        圖像化直覺link:<br/>
        <a href="https://blog.csdn.net/HowardEmily/article/details/72887538" target="_blank">外部連結</a><br/>
    </div>
    <div class="ts text container top attached header">
        2018/8/1 //關於LCA求MST(Minimal Spanning Tree)(最小生成樹)兩點唯一路徑權重最大值
    </div>
    <div class="ts text attached container segment">
        和上一篇一樣，我還是在想TIOJ1163，我看過解答，我始終想不透為何麼LCA可以快速解這問題，<br/>
        結果只是我想多了，其實想法異常粗暴。(EDIT:其實也要用倍增法，詳見下篇文章)<br/><br/>
        這題目大部分會被寫在求次小生成樹的解法上，因為次小生成樹的解法是:<br/>
        先求MST(kruskal算法)，並一一嘗試每一個剩下沒連接到的邊(u,v,w(weight))，
        必定形成環，檢查(u,v)間另外一條路徑上的最大權重，刪掉這edge，
        接上我們正在嘗試的edge(u,v,w)，會得到新的樹權重和，最後輸出權重最小的結果就好。<br/><br/>
        回到正題，這個問題的解法是:<br/>
        ->let LCA=lca(u,v)<br/>
        ->define walk(u,v):<br/>
        ->->assume depth(u)>depth(v) and v is an ancestor of u<br/>
        ->->因為在MST,(u,v)間只有一條路徑，所以我們可以一步一步往u上面的祖先走，並記錄最長的邊(可以用倍增法
        ，詳見下篇文章)<br/>
        ->->得到(u,v)間的最大權重<br/>
        ->end walk<br/>
        ->(因為walk傳入的(u,v)必須是祖先-子孫關係，所以我們必須先求LCA)<br/>
        ->現在我們就可以得到答案是max(walk(u,LCA),walk(v,LCA))<br/>
        ->end<br/>
        備註:我在寫這題時全部測資都SegFault，目前還沒找到原因...(EDIT:解決，詳見下篇文章)<br/><br/>
        放一些文章:<br/>
        TIOJ1163解答<br/>
        <a href="https://blog.ototot.tk/2017/04/tioj-1163-6.html" target="_blank">外部連結</a><br/>
        上面那個文章裡面的連結，關於walk的詳細說明(其實沒有說明，在code裡)<br/>
        <a href="https://blog.ototot.tk/2017/03/tioj-1445.html" target="_blank">外部連結</a><br/>
        另一種用到LCA的解法，只是我不知道怎麼生成那棵樹<br/>
        <a href="http://blog.sina.com.cn/s/blog_51cea4040100ss3n.html" target="_blank">外部連結</a><br/>
        另一種解法，好像是從生成MST時動手，沒看太懂<br/>
        <a href="https://blog.csdn.net/zengchen__acmer/article/details/17323429" target="_blank">外部連結</a><br/>
        次小生成樹<br/>
        <a href="https://oi.men.ci/minimum-spanning-tree-notes/" target="_blank">外部連結</a>
    </div>
    <div class="ts text container top attached header">2018/8/3 //對前兩篇文章的總結</div>
    <div class="ts text attached container segment">
        我終於AC了，雖然排名不是頂端，但我認為可能已經不那麼重要了，畢竟我完全照著網路解答(tototo大佬的那個解答)
        的思路寫，僅僅有一個if條件(lca函式那，不知道為何不用交換u,v如果v比u深)我實在不知道做了什麼神奇的動作可以
        省去和我多紀錄了每個點的depth(深度)來進行一些判斷，
        基本上沒什麼區別，在最後還是差了40ms左右，我就把這個當做是解題系統的誤差吧(。而至於為什麼之前一直SegFault，
        居然是因為我的dfs函式不小心回傳型別寫成int，而我最後並沒有回傳東西，g++ -Wall -Wextra居然什麼都沒有講，
        我花了將近一天半重複debug，最後開Ubuntu虛擬機裝clang編譯，才終於告訴我我忘記回傳了，沒回傳不知道為什麼
        在這情況會產生UB(Undefined Behavior) :(<br/><br/>
        回到正題，現在來說一些從tototo大佬解答整理出來的特殊的優化方法。<br/>
        1.dfs時紀錄每個點的進入/離開時間，撰寫函式anc(ancestor)用以判斷(u,v)兩點的祖先-子孫關係，在最後求lca時
        可以從兩個迴圈變成一個迴圈，大概長這樣:<br/>
        <img class="ts link fluid image" src="優化後的lca.PNG"><br/>
        2.可以省去所有判斷father是否為-1的father初始化方法:不要有"到不了"狀態，也就是不要有-1。<br/>
        具體方法為在初始化時對每一個點的所有祖先都設為自己，如此一來最後原本會是"到不了"的狀態(-1))，會變成端點的號碼。<br/>
        這樣敘述"非常"不清楚，可以自己想像一下。<br/>
        3.倍增法walk優化:這個優化並沒有非常特殊，一般來說都已經倍增法求LCA了，自然會想到用倍增法優化walk函式。<br/>
        具體作法是把father[i][j]的型別從int改成pair<int,int>，第一個欄位是原本的值，第二個欄位就是從i點到i的2^j
        祖先點路徑上權重最大值，參考一下答案應該不難實作。<br/><br/>
        一些連結:<br/>
        高仿oToToT大佬的解答<br/>
        <a href="https://gist.github.com/jeffry1829/afbe03aafb85f3fb356b166469588cc8" target="_blank">外部連結</a><br/>
        無優化解答(然而和優化後解答只差30ms)<br/>
        <a href="https://gist.github.com/jeffry1829/f52c54c99960b5b477ca7e7aba223fa9" target="_blank">外部連結</a>
    </div>
    <div class="ts text container top attached header">2018/8/3 //沒學過asm的人隨手記一記</div>
    <div class="ts text attached container segment">
        上一篇文章提到了因為忘記return所以爆炸。我做了一些小實驗想看看為什麼，雖然最後還是不知道哪裡會發生UB，仍姑且
        記一記。<br/><br/>
        <img class="ts link fluid image" src="dfs_asm1.jpg"><br/>
        圖一(-O2)<br/>
        <img class="ts link fluid image" src="dfs_asm2.jpg"><br/>
        圖二<br/>
        <img class="ts link fluid image" src="dfs_asm3.jpg"><br/>
        圖三<br/>
        <img class="ts link fluid image" src="dfs_asm4.jpg"><br/>
        圖四<br/><br/>
        圖二可以看到sub $0x8 %rsp(64bit的return address size)，圖三可以看到push r13,r12,rbp,rbx，圖四可以看到pop回來
        並且retq(因為是64bit)，雖然因為我不會/也懶得一個一個instructor慢慢查，我只能說乍看之下應該是不會有太大的問題的(
        也就是認為不會產生UB)，也就是仍然無法解釋UB的來龍去脈。(return應該是%eax，已經xor %eax %eax了 應該回傳值會被認為
        是0?)
    </div>
<!--    <div class="ts text container top attached header">TEST</div>
    <div class="ts text attached container segment">
        <pre class="line-numbers" data-line="5">
            <code class="language-clike">
            escaped code
            </code>
        </pre>
    </div>-->
    <div class="ts text container top attached header">2018/8/7 //TIOJ1220</div>
    <div class="ts text attached container segment">
        暫時不作詳細說明，因為僅僅是拿到AC，但複雜度太高<br/>
        原始碼:<br/>
        <a href="https://gist.github.com/jeffry1829/bf9b74a77b87e1ecd65dec426bf6e0d3" target="_blank">外部連結</a>
    </div>
    <div class="ts text container top attached header">2018/8/21 //Codeforce 510C</div>
    <div class="ts text attached container segment">
        <p>
          Key: Topological sort(拓樸排序)<br/>
          大約意思是給定一張DAG(Directed Acyclic Graph有向無環圖)，把所有點展開成連的邊只往下指
          ，輸出一種點的順序滿足點是從最上"層"到最下"層"。<br/>
          至於判斷是否是DAG的方法其中一種是利用dfs，紀錄每一點的離開時間，如果
          dfs到其中一點u時，發現u連到一個點v，但v已進入卻"未離開"，即代表有環存在。
          拓樸排序也可以簡單的由輸出離開時間從最晚到最早得到。<br/>
          原始碼:<br/>
          <a href="https://gist.github.com/jeffry1829/c6da453666e3ec57e2f6ce4f6bf6ae29" target="_blank">外部連結</a>
      </p>
    </div>
    <div class="ts text container top attached header">2018/8/21 //TIOJ1092</div>
    <div class="ts text attached container segment">
      <p>
        Key: dp<br/>
        很多人先得到拓樸排序再從dp(N)回推到dp(1)，但我覺得直接下dp(1)再慢慢遞迴得到答案即可。<br/>
        想法是:一個點如果要(站在上面的人)必勝，必須滿足這個點連出去每個點都必輸，
        同理如果要必輸，這個點連出去至少要有一個點必勝。<br/>
        原始碼:<br/>
        <a href="https://gist.github.com/jeffry1829/78283789a3800239bdd8a4e085907076" target="_blank">外部連結</a>
      </p>
    </div>
    <div class="ts text container top attached header">2018/10/9 //Update</div>
    <div class="ts text attached container segment">
        很久沒更新了，有幾題可以寫解釋。<br/>
        //TIOJ1641<br/>
        dijkstra，但是明明不是單純加上邊權阿?我們可以取log<br/>
        原始碼:<br/>
        <a href="https://gist.github.com/jeffry1829/106aae07b0898f06557016f7f8cdf9cd" target="_blank">外部連結</a><br/>
        <br/>
        //TIOJ1096<br/>
        原始碼:<br/>
        floyd-warshall algo, 找*自己到自己*的最短路。<br/>
        原始碼:<br/>
        <a href="https://gist.github.com/jeffry1829/c838fc0c39a90fe634e9f391135f6f77" target="_blank">外部連結</a><br/>
        <br/>
        //Codeforce 543B<br/>
        首先要意識到這問題等價於求出滿足條件需要最少的edge數<br/>
        接著可以分成兩種情況，1.兩條路徑不相交2.兩條路徑有重疊(邊重疊)<br/>
        bfs求出全點對最短路(因為邊權為一，不需要特別的最短路演算法)，<br/>
        對於第一種情況的路徑邊數為dis(s1t1)+dis(s2t2)(dis:(x,y),x,y的最短路徑長度)，<br/>
        至於對第二種情況，遍歷所有s1t1,s2t2可能的重複路徑(i,j)，取其最小(和狀況一一起比大小)，最終總邊數扣掉最少需要邊數即為解答。<br/>
        原始碼:<br/>
        <a href="https://gist.github.com/jeffry1829/2a510e7db99702000d4b3cdac3d0a292" target="_blank">外部連結</a><br/>
        <br/>
        //zerojudge d518<br/>
        直覺是map(二元樹)或unordered_map(hash+collide解決措施)，非常簡單。但如果用trie實作會MLE，不管怎麼用都沒辦法，待補。<br/>
        原始碼:<br/>
        <a href="https://gist.github.com/jeffry1829/636972fc9560619b38a9c3362852a824" target="_blank">外部連結</a><br/>
        <br/>
        //TIOJ1306<br/>
        hash，rabin fingerprint->可O(1)獲得原字串的子字串的hash。詳見tioj 2016資訊校隊培訓講義字串篇。M取1e9就蠻穩的。<br/>
        實作需要一點點mod的運算，因為數字非常大。要算ap^n+b^(n-1)...yp+z (mod M)可以先算a (mod M)再(*P + b) (mod M)<br/>
        要算(a-b) (mod M)如果直接代公式(((a mod M)-(b mod M))+M)mod M會比let tmp=a-(b mod M); if(tmp&lt;0) tmp+=M;慢兩倍。(詳細
        我也沒推導過)<br/>
        可以去wiki看mod運算規則和程式碼自己推一遍。<br/>
        另外因為記憶體用得有點多，所以大部分時間都用int儲存結果，只有在運算過程中換成long long並最後mod M後再cast成int。<br/>
        例:res = (res * 1ll * _p1 + s[i - 1] * 1ll) % _M;<br/>
        原始碼:<br/>
        <a href="https://gist.github.com/jeffry1829/18a2dd0f3d80baec56f52f9c4687d490" target="_blank">外部連結</a><br/>
        ^基本上不需要用到unsigned long long，接下來放上hash template。<br/>
        原始碼:<br/>
        <a href="https://gist.github.com/jeffry1829/b80e23ccc932d3fd0c5044226045f7b4" target="_blank">外部連結</a><br/>
        <br/>
        //TIOJ1321<br/>
        字串前綴丟到後面可以看成兩倍的字串並偏移起始位置，像是這樣:<br/>
        abcdeabcde<br/>
        cdeab(前二丟到後面)為上方字串從[2]開始長度為原字串長度的子字串。<br/>
        接下來就用hash解題。<br/>
        原始碼:<br/>
        <a href="https://gist.github.com/jeffry1829/5f66e5b264cc9656c168f676aa357e12" target="_blank">外部連結</a><br/>
        <br/>
        //TIOJ1725<br/>
        Gusfield's Algorithm(Z Algorithm)<br/>
        但是如果想知道是否是只差一個字元單純暴力下去會TLE，有個想法:把字串反過來再來一次Z Algo，兩次匹配長度和為N-1，那麼就只差一個字元。<br/>
        詳細:<a href="http://codingbeans.blogspot.com/2016/03/tioj-1725z-algorithm-massacre-at-camp.html" target="_blank">外部連結</a><br/>
        Z Algo一樣可以參考tioj 2016資訊校隊培訓講義字串篇。<br/>
        原始碼:<br/>
        <a href="https://gist.github.com/jeffry1829/8701e5e9236bf6b9b052752cb61bc286" target="_blank">外部連結</a><br/>
    </div>
    <div class="ts text container top attached header">2018/8/1 //JustDoIt</div>
    <div class="ts text attached container segment">
        Do it<br/>
        Just Do it<br/>
        Don't let your dreams be dreams.<br/>
        Yesterday,you said tomorrow.<br/>
        So just do it!!<br/>
        Make your dreams come true!<br/>
        Just do it!!!<br/>
        Some people dream success.<br/>
        While you are gonna wake up and work hard at it!<br/>
        Nothing is impossible!<br/>
        (snorts)<br/>
        You should get to the point where anyone else would quit.<br/>
        And you are not going to (stop) there!<br/>
        NO!What are you waiting for?<br/>
        Do it!<br/>
        Just<br/>
        Do it!<br/>
        Yes we can!<br/>
        Just<br/>
        Do it!<br/>
        If you are tired of starting over,<br/>
        stop giving up<br/>
        and work hard at it<br/>
        <img class="ts link fluid image" src="justdoit.png">
    </div>

    <canvas id="glcanvas" width="320" height="240" style="position: fixed; float:left; z-index: 100;"></canvas>
    <script>sampleApp1();</script>
</body>
</html>